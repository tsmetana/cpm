#!/usr/bin/python3
"""Container Package Manager"""

import dnf
import sys
import os
import pwd
import grp
import stat
import re
from optparse import OptionParser
import traceback
import rpm

class Util():
    def __init__(self):
        self._ignore_files_re = re.compile(r"""^/usr/share/mime/.*
                | ^/etc/passwd-$
                | ^/etc/group-$
                | ^/etc/shadow-$
                | ^/etc/gshadow-$
                | ^/dev/.*
                | ^/sys/.*
                | ^/tmp/.*
                | ^/run/.*
                | ^/var/tmp/.*
                | ^/usr/lib/rpm/?.*
                | ^/var/lib/rpm/?.*
                | ^/var/lib/dnf/?.*
                | .*\.rpmnew$
                | .*\.rpmsave$
                | ^/etc/.pwd.lock$
                """, re.X)

    def input_bool(self, msg):
        """Return True if user answered 'yes' to msg."""
        ans = input(msg).lower()
        return (ans == 'y' or ans == 'yes')


    def hdr_nvr_str(self, h):
        """ Convert the rpm header to n-v-r string """
        # FIXME: Read the locales settings properly
        enc = sys.stdout.encoding
        ret = "%s-%s-%s" % (h['name'].decode(enc),
            h['version'].decode(enc), h['release'].decode(enc))
        return ret

    def is_ignored(self, path):
        return self._ignore_files_re.match(path)


class SpecFile():
    def __init__(self, name=None, version='', release='', summary='',
            license='Proprietary', description='', source = ''
            build_req=[], req=[], files=[], chlog=[]):
        self.name = name
        self.version = version
        self.release = release
        self.summary = summary
        self.license = license
        self.description = description
        self.source = source
        self.build_req = build_req
        self.req = req,
        self.files = files
        self.chlog = chlog

    def write(self, path):
        with open(path, "w") as fw:
            fw.write("""# This file was generated by cpm
Name: %(name)
Version: %(version)s
Release: %(release)s
Summary: %(summary)s
License: %(license)s

Source0: %(source)s
""" % self)
            for br in build_req:
                fw.write("BuildRequires: %s" % br)
            fw.write("""
%description
%(description)s

%prep
%setup -q

%build

%install

""" % self)
            for f in files:
                fw.write("%attr(%o, %s, %s) %s" % (f['mode'], f['user'], f['group'],
                    f['path']))


class MainApp():
    def __init__(self):
        self.util = Util()


    def _check_installroot(self, installroot):
        if not os.path.isdir(installroot):
            raise OSError("The target directory '%s' does not exist."
                    % (installroot,))


    def _parse_argv(self, argv):
        parser = OptionParser()
        parser.add_option("-m", "--machine", dest = "machine",
                help = "Name of the machine")
        parser.add_option("-D", "--directory", dest = "directory",
                help = "Use DIR as the base containers directory", metavar="DIR")
        return parser.parse_args(args = argv)


    def _setup_base(self, base, installroot):
        rel = dnf.rpm.detect_releasever(base.conf.installroot)
        base.conf.substitutions['releasever'] = rel
        base.read_all_repos()
        base.conf.installroot = installroot
        base.fill_sack(load_system_repo=False)


    def _guess_machines_dir(self):
        # Find the default directory with containers/machines
        # This list has been taken from the machinectl manual page
        search_list = ['/var/lib/machines',
                '/usr/local/lib/machines',
                '/usr/lib/machines',
                '/var/lib/container']
        ret = None
        for d in search_list:
            if os.path.isdir(d):
                ret = d
                break
        if not ret:
            # Meh... so, this one
            ret = '/var/lib/machines'

        return ret


    def _install(self, installroot, pkgs):
        # If the machine directory doesn't exist, try to create it
        if not os.path.isdir(installroot):
            if self.util.input_bool("The machine base directory '%s' does not exist. Create now? [y/N]: "
                    % installroot):
                os.makedirs(installroot)
            else:
                raise OSError("The target directory '%s' does not exist."
                    % (installroot,))
        with dnf.Base() as base:
            self._setup_base(base, installroot)
            for p in pkgs:
                base.install(p)
            base.resolve()
            base.download_packages(base.transaction.install_set)
            base.do_transaction()


    def _upgrade(self, installroot, pkgs):
        self._check_installroot(installroot)
        with dnf.Base() as base:
            self._setup_base(base, installroot)
        if len(pkgs) > 0:
            base.upgrade(pkgs)
        else:
            base.upgrade_all()
        base.resolve()
        base.download_packages(base.transaction.install_set)
        base.do_transaction()


    def _remove(self, installroot, pkgs):
        self._check_installroot(installroot)
        with dnf.Base() as base:
            self._setup_base(base, installroot)
            for p in pkgs:
                base.remove(p)
            base.resolve()
            base.do_transaction()


    def _list(self, installroot):
        rpmdb_path = os.path.normpath(installroot + "/var/lib/rpm")
        rpm.addMacro("_dbpath", rpmdb_path)
        ts = rpm.TransactionSet()
        mi = ts.dbMatch()
        for m in mi:
            print(self.util.hdr_nvr_str(m))


    def _check_orphan(self, ts, path):
        mi = ts.dbMatch(rpm.RPMDBI_INSTFILENAMES, path)
        if (len(mi) == 0) and not self.util.is_ignored(path):
            try:
                st = os.stat(path)
            except FileNotFoundError:
                return None
            return {'path': path,
                    'mode': stat.S_IMODE(st.st_mode),
                    'user': pwd.getpwuid(st.st_uid).pw_name,
                    'group': grp.getgrgid(st.st_gid).gr_name }
        return None


    def _checkinstall(self, installroot):
        # TODO: Is it really always /var/lib/rpm? Should be able to figure out...
        rpmdb_path = os.path.normpath(installroot + "/var/lib/rpm")
        print("Scanning '%s'..." %(installroot,))
        rpm.addMacro("_dbpath", rpmdb_path)
        ts = rpm.TransactionSet()
        save_wd = os.getcwd()
        orphans = []
        os.chdir(installroot)
        for root, dirs, files in os.walk('.'):
            for name in dirs + files:
                f = os.path.normpath(root[1:] + '/' + name)
                orphan = self._check_orphan(ts, f)
                if orphan:
                    orphans.append(orphan)

        os.chdir(save_wd)
        print("Done. Found %d orphan files." % (len(orphans),))
        for f in orphans:
            print("%o, %s, %s: %s" % (f['mode'], f['user'], f['group'],
                f['path']))

    def run(self, argv):
        opts, pos_args = self._parse_argv(argv)
        if len(pos_args) == 0:
            raise RuntimeError('No action specified')
        action = pos_args[0]
        machine = opts.machine
        machines_dir = opts.directory
        if not machine:
            raise RuntimeError("The machine name (-m) must be specified")
        if not machines_dir:
            machines_dir = self._guess_machines_dir()
        machine_root = os.path.normpath(machines_dir + '/' + machine)

        if action == 'install':
            self._install(machine_root, pos_args[1:])
        elif action == 'update' or action == 'upgrade':
            self._upgrade(machine_root, pos_args[1:])
        elif action == 'remove' or action == 'delete':
            self._remove(machine_root, pos_args[1:])
        elif action == 'list':
            self._list(machine_root)
        elif action == 'checkinstall':
            self._checkinstall(machine_root)
        else:
            raise RuntimeError("Unkown action: '%s'" % (action,))


if __name__ == '__main__':
    app = MainApp();
    try:
        app.run(sys.argv[1:])
        sys.exit(0)
    except Exception as e:
        traceback.print_exc()
        sys.exit(e)

# vim: set expandtab: syntax=python:
