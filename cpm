#!/usr/bin/python3
"""Container Package Manager"""
#
# This copyrighted material is made available to anyone wishing to use,
# modify, copy, or redistribute it subject to the terms and conditions of
# the GNU General Public License v.2, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY expressed or implied, including the implied warranties of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# (c) 2015 Tomas Smetana <tomas@smetana.name>
#
# The leaf search algorithm stolen from the GPLv2+ licensed leaves dnf plugin
# by Emil Renner Berthing.
#
import dnf
import sys
import os
import pwd
import grp
import stat
import re
from optparse import OptionParser
import traceback
import rpm
import subprocess
from tempfile import NamedTemporaryFile

class Util(object):
    def __init__(self):
        self._ignore_files_re = re.compile(r"""^/usr/share/mime/.*
                | ^/etc/passwd-$
                | ^/etc/group-$
                | ^/etc/shadow-$
                | ^/etc/gshadow-$
                | ^/dev/.*
                | ^/sys/.*
                | ^/tmp/.*
                | ^/run/.*
                | ^/var/tmp/.*
                | ^/usr/lib/rpm/?.*
                | ^/var/lib/rpm/?.*
                | ^/var/lib/dnf/?.*
                | .*\.rpmnew$
                | .*\.rpmsave$
                | ^/etc/.pwd.lock$
                """, re.X)


    def input_bool(self, msg):
        """Return True if user answered 'yes' to msg."""
        ans = input(msg).lower()
        return (ans == 'y' or ans == 'yes')


    def hdr_nvr_str(self, h):
        """ Convert the rpm header to n-v-r string """
        # FIXME: Read the locales settings properly
        enc = sys.stdout.encoding
        ret = "%s-%s-%s" % (h['name'].decode(enc),
            h['version'].decode(enc), h['release'].decode(enc))
        return ret


    def is_ignored(self, path):
        return self._ignore_files_re.match(path)


class SpecFile(object):
    def __init__(self, name = 'unnamed',
            version = '1.0',
            release = '1',
            summary = None,
            license = 'Proprietary',
            description = None,
            source = None,
            req = None, files = None):
        self.name = name
        self.version = version
        self.release = release
        self.summary = summary if summary else "Autogenerated '%s' container" % (name,)
        self.license = license
        self.description = description if description else self.summary
        self.source = source if source else "%s-%s.tar.bz2" % (name, version)
        self.req = req or []
        self.files = files or []
        self.specname = "%s-%s-%s.spec" % (name, version, release)
        self.sourcedir = subprocess.check_output(['rpmbuild', '-E',
            '%{_sourcedir}'], universal_newlines = True)[:-1]
        self.specdir = subprocess.check_output(['rpmbuild', '-E',
            '%{_specdir}'], universal_newlines = True)[:-1]
        self.path = os.path.normpath(self.specdir + '/' + self.specname)


    def write(self):
        with open(self.path, "w") as fw:
            fw.write("""# This file was generated by cpm
Name: %(name)s
Version: %(version)s
Release: %(release)s%%{?dist}
Summary: %(summary)s
License: %(license)s

Source0: %(source)s

""" % self.__dict__)
            for r in self.req:
                fw.write("Requires: %s >= %s" % (r.name, r.evr))
            fw.write("""

%%description
%(description)s

%%prep
rm -rf %%{buildroot}

%%build

%%install
# Only unpack the content of the source file
cd %%{buildroot}
tar xxvf %%{SOURCE0}

%%files
""" % self.__dict__)
            for f in self.files:
                fw.write("%%attr(%(mode)o, %(user)s, %(group)s) %(path)s\n" % f)
            fw.flush()


    def mksourcefile(self, installroot):
        if not os.path.isdir(self.sourcedir):
                os.makedirs(self.sourcedir)
        tarball = os.path.normpath(self.sourcedir + "/" + self.source)
        filelist = NamedTemporaryFile()
        for f in self.files:
            filelist.write(b'.')
            filelist.write(bytes(f['path'], 'utf-8'))
            filelist.write(b'\n')
        filelist.flush()
        print("Creating source file '%s'" % tarball)
        save_wd = os.getcwd()
        os.chdir(installroot)
        subprocess.check_call(["tar", "cjvf", tarball, "-T", filelist.name])
        os.chdir(save_wd)
        filelist.close()


    def buildrpm(self):
        subprocess.check_call(["rpmbuild", "-bb", self.path])


class MainApp(object):
    def __init__(self):
        self.machine = None
        self.util = Util()


    def _check_installroot(self, installroot):
        if not os.path.isdir(installroot):
            raise OSError("The target directory '%s' does not exist."
                    % (installroot,))


    def _parse_argv(self, argv):
        parser = OptionParser()
        parser.add_option("-m", "--machine", dest = "machine",
                help = "Name of the machine")
        parser.add_option("-D", "--directory", dest = "directory",
                help = "Use DIR as the base containers directory", metavar="DIR")
        return parser.parse_args(args = argv)


    def _setup_base(self, base, installroot, sysrepo = False):
        rel = dnf.rpm.detect_releasever(base.conf.installroot)
        base.conf.substitutions['releasever'] = rel
        base.read_all_repos()
        base.conf.installroot = installroot
        base.conf.tsflags.append('nodocs')
        base.fill_sack(load_system_repo = sysrepo)


    def _guess_machines_dir(self):
        # Find the default directory with containers/machines
        # This list has been taken from the machinectl manual page
        search_list = ['/var/lib/machines',
                '/usr/local/lib/machines',
                '/usr/lib/machines',
                '/var/lib/container']
        ret = None
        for d in search_list:
            if os.path.isdir(d):
                ret = d
                break
        if not ret:
            # Meh... so, this one
            ret = '/var/lib/machines'

        return ret


    def _install(self, installroot, pkgs):
        # If the machine directory doesn't exist, try to create it
        if not os.path.isdir(installroot):
            if self.util.input_bool("The machine base directory '%s' does not exist. Create now? [y/N]: "
                    % installroot):
                os.makedirs(installroot)
            else:
                raise OSError("The target directory '%s' does not exist."
                    % (installroot,))
        with dnf.Base() as base:
            self._setup_base(base, installroot)
            for p in pkgs:
                base.install(p)
            base.resolve()
            base.download_packages(base.transaction.install_set)
            base.do_transaction()


    def _upgrade(self, installroot, pkgs):
        self._check_installroot(installroot)
        with dnf.Base() as base:
            self._setup_base(base, installroot, sysrepo = True)
        if len(pkgs) > 0:
            base.upgrade(pkgs)
        else:
            base.upgrade_all()
        base.resolve()
        base.download_packages(base.transaction.install_set)
        base.do_transaction()


    def _remove(self, installroot, pkgs):
        self._check_installroot(installroot)
        with dnf.Base() as base:
            self._setup_base(base, installroot, sysrepo = True)
            for p in pkgs:
                base.remove(p)
            base.resolve()
            base.do_transaction()


    def _list(self, installroot):
        rpmdb_path = os.path.normpath(installroot + "/var/lib/rpm")
        rpm.addMacro("_dbpath", rpmdb_path)
        ts = rpm.TransactionSet()
        mi = ts.dbMatch()
        for m in mi:
            print(self.util.hdr_nvr_str(m))


    def _check_orphan(self, ts, path):
        mi = ts.dbMatch(rpm.RPMDBI_INSTFILENAMES, path)
        if (len(mi) == 0) and not self.util.is_ignored(path):
            try:
                st = os.stat(path)
            except FileNotFoundError:
                return None
            return {'path': path,
                    'mode': stat.S_IMODE(st.st_mode),
                    'user': pwd.getpwuid(st.st_uid).pw_name,
                    'group': grp.getgrgid(st.st_gid).gr_name }
        return None


    def _buildgraph(self, base):
        """
        Load the list of installed packages and their dependencies using
        hawkey, and build the dependency graph and the graph of reverse
        dependencies.
        """
        sack = dnf.sack.rpmdb_sack(base)
        pkgmap = dict()
        packages = []
        depends = []
        rdepends = []
        deps = set()
        providers = set()

        for i, pkg in enumerate(sack.query()):
            pkgmap[pkg] = i
            packages.append(pkg)
            rdepends.append([])

        for i, pkg in enumerate(packages):
            for req in pkg.requires:
                sreq = str(req)
                if sreq.startswith('rpmlib(') or sreq == 'solvable:prereqmarker':
                    continue
                for dpkg in sack.query().filter(provides=req):
                    providers.add(pkgmap[dpkg])
                if i not in providers:
                    deps.update(providers)
                providers.clear()

            deplist = list(deps)
            deps.clear()
            depends.append(deplist)
            for j in deplist:
                rdepends[j].append(i)

        return (packages, depends, rdepends)


    def _kosaraju(self, graph, rgraph):
        """
        Run Kosaraju's algorithm to find strongly connected components
        in the graph, and return the list of nodes in the components
        without any incoming edges.
        """
        N = len(graph)
        rstack = []
        stack = []
        tag = [False] * N

        # do depth-first searches in the graph
        # and push nodes to rstack "on the way up"
        # until all nodes have been pushed.
        # tag nodes so we don't visit them more than once
        for u in range(N):
            if tag[u]:
                continue

            stack.append(u)
            tag[u] = True
            while stack:
                u = stack[-1]
                if u >= 0:
                    stack[-1] = -1 - u
                    for v in graph[u]:
                        if not tag[v]:
                            stack.append(v)
                            tag[v] = True
                else:
                    stack.pop()
                    rstack.append(-1 - u)

        # now searches beginning at nodes popped from
        # rstack in the graph with all edges reversed
        # will give us the strongly connected components.
        # the incoming edges to each component is the
        # union of incoming edges to each node in the
        # component minus the incoming edges from
        # component nodes themselves.
        # now all nodes are tagged, so this time let's
        # remove the tags as we visit each node.
        leaves = []
        scc = []
        sccredges = set()
        while rstack:
            v = rstack.pop()
            if not tag[v]:
                continue

            stack.append(v)
            tag[v] = False
            while stack:
                v = stack.pop()
                redges = rgraph[v]
                scc.append(v)
                sccredges.update(redges)
                for u in redges:
                    if tag[u]:
                        stack.append(u)
                        tag[u] = False

            sccredges.difference_update(scc)
            if not sccredges:
                leaves.extend(scc)
            del scc[:]
            sccredges.clear()

        return leaves


    def _find_leaves(self, installroot):
        with dnf.Base() as base:
            self._setup_base(base, installroot)
            (packages, depends, rdepends) = self._buildgraph(base)
            return [packages[i] for i in self._kosaraju(depends, rdepends)]


    def _checkinstall(self, installroot):
        # TODO: Is it really always /var/lib/rpm? Should be able to figure out...
        rpmdb_path = os.path.normpath(installroot + "/var/lib/rpm")
        print("Scanning '%s'..." %(installroot,))
        rpm.addMacro("_dbpath", rpmdb_path)
        ts = rpm.TransactionSet()
        save_wd = os.getcwd()
        orphans = []
        os.chdir(installroot)
        for root, dirs, files in os.walk('.'):
            for name in dirs + files:
                f = os.path.normpath(root[1:] + '/' + name)
                orphan = self._check_orphan(ts, f)
                if orphan:
                    orphans.append(orphan)

        os.chdir(save_wd)
        print("Done. Found %d orphan files." % (len(orphans),))
        print("Looking for leaf packages...")
        leaves = self._find_leaves(installroot)
        spec = SpecFile(name = self.machine, files = orphans, req = leaves)
        spec.mksourcefile(installroot)
        print("Writing '%s'" % spec.path)
        spec.write()
        print("Building binary package from '%s'" % spec.path)
        spec.buildrpm()


    def run(self, argv):
        opts, pos_args = self._parse_argv(argv)
        if len(pos_args) == 0:
            raise RuntimeError('No action specified')
        action = pos_args[0]
        self.machine = opts.machine
        machines_dir = opts.directory
        if not self.machine:
            raise RuntimeError("The machine name (-m) must be specified")
        if not machines_dir:
            machines_dir = self._guess_machines_dir()
        machine_root = os.path.normpath(machines_dir + '/' + self.machine)

        if action == 'install':
            self._install(machine_root, pos_args[1:])
        elif action == 'update' or action == 'upgrade':
            self._upgrade(machine_root, pos_args[1:])
        elif action == 'remove' or action == 'delete':
            self._remove(machine_root, pos_args[1:])
        elif action == 'list':
            self._list(machine_root)
        elif action == 'checkinstall':
            self._checkinstall(machine_root)
        else:
            raise RuntimeError("Unkown action: '%s'" % (action,))


if __name__ == '__main__':
    app = MainApp();
    try:
        app.run(sys.argv[1:])
        sys.exit(0)
    except Exception as e:
        traceback.print_exc()
        sys.exit(e)

# vim: set expandtab: syntax=python:
