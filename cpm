#!/usr/bin/python3
"""Container Package Manager"""

import dnf
import sys
import os
import pwd
import grp
import stat
import re
from optparse import OptionParser
import traceback
import rpm
import subprocess
from tempfile import NamedTemporaryFile

class Util(object):
    def __init__(self):
        self._ignore_files_re = re.compile(r"""^/usr/share/mime/.*
                | ^/etc/passwd-$
                | ^/etc/group-$
                | ^/etc/shadow-$
                | ^/etc/gshadow-$
                | ^/dev/.*
                | ^/sys/.*
                | ^/tmp/.*
                | ^/run/.*
                | ^/var/tmp/.*
                | ^/usr/lib/rpm/?.*
                | ^/var/lib/rpm/?.*
                | ^/var/lib/dnf/?.*
                | .*\.rpmnew$
                | .*\.rpmsave$
                | ^/etc/.pwd.lock$
                """, re.X)


    def input_bool(self, msg):
        """Return True if user answered 'yes' to msg."""
        ans = input(msg).lower()
        return (ans == 'y' or ans == 'yes')


    def hdr_nvr_str(self, h):
        """ Convert the rpm header to n-v-r string """
        # FIXME: Read the locales settings properly
        enc = sys.stdout.encoding
        ret = "%s-%s-%s" % (h['name'].decode(enc),
            h['version'].decode(enc), h['release'].decode(enc))
        return ret


    def is_ignored(self, path):
        return self._ignore_files_re.match(path)


class SpecFile(object):
    def __init__(self, name = 'unnamed',
            version = '1.0',
            release = '1',
            summary = None,
            license = 'Proprietary',
            description = None,
            source = None,
            req = None, files = None):
        self.name = name
        self.version = version
        self.release = release
        self.summary = summary if summary else "Autogenerated '%s' container" % (name,)
        self.license = license
        self.description = description if description else self.summary
        self.source = source if source else "%s-%s.tar.bz2" % (name, version)
        self.req = req or []
        self.files = files or []
        self.path = "%s-%s-%s.spec" % (name, version, release)
        self.sourcedir = subprocess.check_output(['rpmbuild', '-E',
            '%{_sourcedir}'], universal_newlines = True)[:-1]
        self.specdir = subprocess.check_output(['rpmbuild', '-E',
            '%{_specdir}'], universal_newlines = True)[:-1]


    def write(self):
        with open(self.path, "w") as fw:
            fw.write("""# This file was generated by cpm
Name: %(name)s
Version: %(version)s
Release: %(release)s%%{?dist}
Summary: %(summary)s
License: %(license)s

Source0: %(source)s
""" % self.__dict__)
            for r in self.req:
                fw.write("Requires: %s" % r)
            fw.write("""
%%description
%(description)s

%%prep
rm -rf %%{buildroot}

%%build

%%install
# Only unpack the content of the source file
cd %%{buildroot}
tar xxvf %%{SOURCE0}

%%files
""" % self.__dict__)
            for f in self.files:
                fw.write("%%attr(%(mode)o, %(user)s, %(group)s) %(path)s\n" % f)


    def mksourcefile(self, installroot):
        if not os.path.isdir(self.sourcedir):
                os.makedirs(self.sourcedir)
        tarball = os.path.normpath(self.sourcedir + "/" + self.source)
        filelist = NamedTemporaryFile()
        for f in self.files:
            filelist.write(b'.')
            filelist.write(bytes(f['path'], 'utf-8'))
            filelist.write(b'\n')
        filelist.flush()
        print("Creating source file '%s'" % tarball)
        save_wd = os.getcwd()
        os.chdir(installroot)
        subprocess.check_call(["tar", "cjvf", tarball, "-T", filelist.name])
        os.chdir(save_wd)
        filelist.close()


    def buildrpm(self):
        specpath = os.path.normpath(self.specdir + "/" + self.path)
        subprocess.check_call(["rpmbuild", "-bb", specpath])


class MainApp(object):
    def __init__(self):
        self.machine = None
        self.util = Util()


    def _check_installroot(self, installroot):
        if not os.path.isdir(installroot):
            raise OSError("The target directory '%s' does not exist."
                    % (installroot,))


    def _parse_argv(self, argv):
        parser = OptionParser()
        parser.add_option("-m", "--machine", dest = "machine",
                help = "Name of the machine")
        parser.add_option("-D", "--directory", dest = "directory",
                help = "Use DIR as the base containers directory", metavar="DIR")
        return parser.parse_args(args = argv)


    def _setup_base(self, base, installroot):
        rel = dnf.rpm.detect_releasever(base.conf.installroot)
        base.conf.substitutions['releasever'] = rel
        base.read_all_repos()
        base.conf.installroot = installroot
        base.fill_sack(load_system_repo=False)


    def _guess_machines_dir(self):
        # Find the default directory with containers/machines
        # This list has been taken from the machinectl manual page
        search_list = ['/var/lib/machines',
                '/usr/local/lib/machines',
                '/usr/lib/machines',
                '/var/lib/container']
        ret = None
        for d in search_list:
            if os.path.isdir(d):
                ret = d
                break
        if not ret:
            # Meh... so, this one
            ret = '/var/lib/machines'

        return ret


    def _install(self, installroot, pkgs):
        # If the machine directory doesn't exist, try to create it
        if not os.path.isdir(installroot):
            if self.util.input_bool("The machine base directory '%s' does not exist. Create now? [y/N]: "
                    % installroot):
                os.makedirs(installroot)
            else:
                raise OSError("The target directory '%s' does not exist."
                    % (installroot,))
        with dnf.Base() as base:
            self._setup_base(base, installroot)
            for p in pkgs:
                base.install(p)
            base.resolve()
            base.download_packages(base.transaction.install_set)
            base.do_transaction()


    def _upgrade(self, installroot, pkgs):
        self._check_installroot(installroot)
        with dnf.Base() as base:
            self._setup_base(base, installroot)
        if len(pkgs) > 0:
            base.upgrade(pkgs)
        else:
            base.upgrade_all()
        base.resolve()
        base.download_packages(base.transaction.install_set)
        base.do_transaction()


    def _remove(self, installroot, pkgs):
        self._check_installroot(installroot)
        with dnf.Base() as base:
            self._setup_base(base, installroot)
            for p in pkgs:
                base.remove(p)
            base.resolve()
            base.do_transaction()


    def _list(self, installroot):
        rpmdb_path = os.path.normpath(installroot + "/var/lib/rpm")
        rpm.addMacro("_dbpath", rpmdb_path)
        ts = rpm.TransactionSet()
        mi = ts.dbMatch()
        for m in mi:
            print(self.util.hdr_nvr_str(m))


    def _check_orphan(self, ts, path):
        mi = ts.dbMatch(rpm.RPMDBI_INSTFILENAMES, path)
        if (len(mi) == 0) and not self.util.is_ignored(path):
            try:
                st = os.stat(path)
            except FileNotFoundError:
                return None
            return {'path': path,
                    'mode': stat.S_IMODE(st.st_mode),
                    'user': pwd.getpwuid(st.st_uid).pw_name,
                    'group': grp.getgrgid(st.st_gid).gr_name }
        return None


    def _find_leaves(self, ts):
        mi = ts.dbMatch()
        provides = {}
        leaves = {}
        for m in mi:
            leaves[m['name']] = True
            for p in m['PROVIDENAME']:
                provides[p] = {}
                provides[p]['pkg'] = m['name']
                provides[p]['req'] = False
        mi = ts.dbMatch()
        for m in mi:
            for r in m['REQUIRENAME']:
                provides[r]['req'] = True
        for p in provides:
            if provides[p]['req']:
                try:
                    print("Deleting form leaves list: %s" % (provides[p]['pkg']))
                    del leaves[provides[p]['pkg']]
                except KeyError:
                    pass
        print("Found %d leaf packages" % (len(leaves)))
        for p in leaves:
            print("%s" % p)



    def _checkinstall(self, installroot):
        # TODO: Is it really always /var/lib/rpm? Should be able to figure out...
        rpmdb_path = os.path.normpath(installroot + "/var/lib/rpm")
        print("Scanning '%s'..." %(installroot,))
        rpm.addMacro("_dbpath", rpmdb_path)
        ts = rpm.TransactionSet()
        save_wd = os.getcwd()
        orphans = []
        os.chdir(installroot)
        for root, dirs, files in os.walk('.'):
            for name in dirs + files:
                f = os.path.normpath(root[1:] + '/' + name)
                orphan = self._check_orphan(ts, f)
                if orphan:
                    orphans.append(orphan)

        os.chdir(save_wd)
        print("Done. Found %d orphan files." % (len(orphans),))
        print("Looking for leaf packages...")
        self._find_leaves(ts)
        spec = SpecFile(name = self.machine, files = orphans)
        spec.mksourcefile(installroot)
        print("Writing '%s'" % spec.path)
        spec.write()
        print("Building binary package of '%s'" % spec.path)
        spec.buildrpm()

    def run(self, argv):
        opts, pos_args = self._parse_argv(argv)
        if len(pos_args) == 0:
            raise RuntimeError('No action specified')
        action = pos_args[0]
        self.machine = opts.machine
        machines_dir = opts.directory
        if not self.machine:
            raise RuntimeError("The machine name (-m) must be specified")
        if not machines_dir:
            machines_dir = self._guess_machines_dir()
        machine_root = os.path.normpath(machines_dir + '/' + self.machine)

        if action == 'install':
            self._install(machine_root, pos_args[1:])
        elif action == 'update' or action == 'upgrade':
            self._upgrade(machine_root, pos_args[1:])
        elif action == 'remove' or action == 'delete':
            self._remove(machine_root, pos_args[1:])
        elif action == 'list':
            self._list(machine_root)
        elif action == 'checkinstall':
            self._checkinstall(machine_root)
        else:
            raise RuntimeError("Unkown action: '%s'" % (action,))


if __name__ == '__main__':
    app = MainApp();
    try:
        app.run(sys.argv[1:])
        sys.exit(0)
    except Exception as e:
        traceback.print_exc()
        sys.exit(e)

# vim: set expandtab: syntax=python:
